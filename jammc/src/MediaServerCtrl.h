/***************************************************************************|
|  Jamm - Just another multimedia ...                                       |
|         ... set of applications and libraries based on the UPnP-AV specs  |
|                                                                           |
|  Copyright (C) 2009                                                       |
|  JÃ¶rg Bakker (joerg'at'hakker'dot'de)                                     |
|                                                                           |
|  This file is part of Jamm.                                               |
|                                                                           |
|  Jamm is free software: you can redistribute it and/or modify             |
|  it under the terms of the GNU General Public License as published by     |
|  the Free Software Foundation version 3 of the License.                   |
|                                                                           |
|  Jamm is distributed in the hope that it will be useful,                  |
|  but WITHOUT ANY WARRANTY; without even the implied warranty of           |
|  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
|  GNU General Public License for more details.                             |
|                                                                           |
|  You should have received a copy of the GNU General Public License        |
|  along with this program.  If not, see <http://www.gnu.org/licenses/>.    |
***************************************************************************/

/***************************************************************************|
|                               WARNING                                     |
|        This file is generated by the jamm stub generator jammgen.         |
|       Don't edit, it will be overriden at the next run of jammgen.        |
***************************************************************************/

#ifndef MEDIASERVER_CTRL_H
#define MEDIASERVER_CTRL_H

#include <jamm/upnp.h>

class AVTransportController
{
    friend class MediaServerController;

public:
    void SetAVTransportURI(const Jamm::ui4& InstanceID, const std::string& CurrentURI, const std::string& CurrentURIMetaData);
    void GetMediaInfo(const Jamm::ui4& InstanceID, Jamm::ui4& NrTracks, std::string& MediaDuration, std::string& CurrentURI, std::string& CurrentURIMetaData, std::string& NextURI, std::string& NextURIMetaData, std::string& PlayMedium, std::string& RecordMedium, std::string& WriteStatus);
    void GetTransportInfo(const Jamm::ui4& InstanceID, std::string& CurrentTransportState, std::string& CurrentTransportStatus, std::string& CurrentSpeed);
    void GetPositionInfo(const Jamm::ui4& InstanceID, Jamm::ui4& Track, std::string& TrackDuration, std::string& TrackMetaData, std::string& TrackURI, std::string& RelTime, std::string& AbsTime, Jamm::i4& RelCount, Jamm::i4& AbsCount);
    void GetDeviceCapabilities(const Jamm::ui4& InstanceID, std::string& PlayMedia, std::string& RecMedia, std::string& RecQualityModes);
    void GetTransportSettings(const Jamm::ui4& InstanceID, std::string& PlayMode, std::string& RecQualityMode);
    void Stop(const Jamm::ui4& InstanceID);
    void Play(const Jamm::ui4& InstanceID, const std::string& Speed);
    void Pause(const Jamm::ui4& InstanceID);
    void Seek(const Jamm::ui4& InstanceID, const std::string& Unit, const std::string& Target);
    void Next(const Jamm::ui4& InstanceID);
    void Previous(const Jamm::ui4& InstanceID);

    void _reqSetAVTransportURI(const Jamm::ui4& InstanceID, const std::string& CurrentURI, const std::string& CurrentURIMetaData);
    void _reqGetMediaInfo(const Jamm::ui4& InstanceID, );
    void _reqGetTransportInfo(const Jamm::ui4& InstanceID, );
    void _reqGetPositionInfo(const Jamm::ui4& InstanceID, );
    void _reqGetDeviceCapabilities(const Jamm::ui4& InstanceID, );
    void _reqGetTransportSettings(const Jamm::ui4& InstanceID, );
    void _reqStop(const Jamm::ui4& InstanceID);
    void _reqPlay(const Jamm::ui4& InstanceID, const std::string& Speed);
    void _reqPause(const Jamm::ui4& InstanceID);
    void _reqSeek(const Jamm::ui4& InstanceID, const std::string& Unit, const std::string& Target);
    void _reqNext(const Jamm::ui4& InstanceID);
    void _reqPrevious(const Jamm::ui4& InstanceID);

    std::string _getLastChange();

protected:
    virtual void _ansSetAVTransportURI(const Jamm::ui4& InstanceID, const std::string& CurrentURI, const std::string& CurrentURIMetaData) = 0;
    virtual void _ansGetMediaInfo(const Jamm::ui4& InstanceID, const Jamm::ui4& NrTracks, const std::string& MediaDuration, const std::string& CurrentURI, const std::string& CurrentURIMetaData, const std::string& NextURI, const std::string& NextURIMetaData, const std::string& PlayMedium, const std::string& RecordMedium, const std::string& WriteStatus) = 0;
    virtual void _ansGetTransportInfo(const Jamm::ui4& InstanceID, const std::string& CurrentTransportState, const std::string& CurrentTransportStatus, const std::string& CurrentSpeed) = 0;
    virtual void _ansGetPositionInfo(const Jamm::ui4& InstanceID, const Jamm::ui4& Track, const std::string& TrackDuration, const std::string& TrackMetaData, const std::string& TrackURI, const std::string& RelTime, const std::string& AbsTime, const Jamm::i4& RelCount, const Jamm::i4& AbsCount) = 0;
    virtual void _ansGetDeviceCapabilities(const Jamm::ui4& InstanceID, const std::string& PlayMedia, const std::string& RecMedia, const std::string& RecQualityModes) = 0;
    virtual void _ansGetTransportSettings(const Jamm::ui4& InstanceID, const std::string& PlayMode, const std::string& RecQualityMode) = 0;
    virtual void _ansStop(const Jamm::ui4& InstanceID) = 0;
    virtual void _ansPlay(const Jamm::ui4& InstanceID, const std::string& Speed) = 0;
    virtual void _ansPause(const Jamm::ui4& InstanceID) = 0;
    virtual void _ansSeek(const Jamm::ui4& InstanceID, const std::string& Unit, const std::string& Target) = 0;
    virtual void _ansNext(const Jamm::ui4& InstanceID) = 0;
    virtual void _ansPrevious(const Jamm::ui4& InstanceID) = 0;

    virtual void _changedLastChange(const std::string& val) = 0;

private:
    void _threadSetAVTransportURI(Jamm::Action* pAction);
    void _threadGetMediaInfo(Jamm::Action* pAction);
    void _threadGetTransportInfo(Jamm::Action* pAction);
    void _threadGetPositionInfo(Jamm::Action* pAction);
    void _threadGetDeviceCapabilities(Jamm::Action* pAction);
    void _threadGetTransportSettings(Jamm::Action* pAction);
    void _threadStop(Jamm::Action* pAction);
    void _threadPlay(Jamm::Action* pAction);
    void _threadPause(Jamm::Action* pAction);
    void _threadSeek(Jamm::Action* pAction);
    void _threadNext(Jamm::Action* pAction);
    void _threadPrevious(Jamm::Action* pAction);

    Jamm::Service* m_pService;
};

class ConnectionManagerController
{
    friend class MediaServerController;

public:
    void GetProtocolInfo(std::string& Source, std::string& Sink);
    void ConnectionComplete(const Jamm::i4& ConnectionID);
    void GetCurrentConnectionIDs(std::string& ConnectionIDs);
    void GetCurrentConnectionInfo(const Jamm::i4& ConnectionID, Jamm::i4& RcsID, Jamm::i4& AVTransportID, std::string& ProtocolInfo, std::string& PeerConnectionManager, Jamm::i4& PeerConnectionID, std::string& Direction, std::string& Status);

    void _reqGetProtocolInfo();
    void _reqConnectionComplete(const Jamm::i4& ConnectionID);
    void _reqGetCurrentConnectionIDs();
    void _reqGetCurrentConnectionInfo(const Jamm::i4& ConnectionID, );

    std::string _getSourceProtocolInfo();
    std::string _getSinkProtocolInfo();
    std::string _getCurrentConnectionIDs();

protected:
    virtual void _ansGetProtocolInfo(const std::string& Source, const std::string& Sink) = 0;
    virtual void _ansConnectionComplete(const Jamm::i4& ConnectionID) = 0;
    virtual void _ansGetCurrentConnectionIDs(const std::string& ConnectionIDs) = 0;
    virtual void _ansGetCurrentConnectionInfo(const Jamm::i4& ConnectionID, const Jamm::i4& RcsID, const Jamm::i4& AVTransportID, const std::string& ProtocolInfo, const std::string& PeerConnectionManager, const Jamm::i4& PeerConnectionID, const std::string& Direction, const std::string& Status) = 0;

    virtual void _changedSourceProtocolInfo(const std::string& val) = 0;
    virtual void _changedSinkProtocolInfo(const std::string& val) = 0;
    virtual void _changedCurrentConnectionIDs(const std::string& val) = 0;

private:
    void _threadGetProtocolInfo(Jamm::Action* pAction);
    void _threadConnectionComplete(Jamm::Action* pAction);
    void _threadGetCurrentConnectionIDs(Jamm::Action* pAction);
    void _threadGetCurrentConnectionInfo(Jamm::Action* pAction);

    Jamm::Service* m_pService;
};

class ContentDirectoryController
{
    friend class MediaServerController;

public:
    void GetSearchCapabilities(std::string& SearchCaps);
    void GetSortCapabilities(std::string& SortCaps);
    void GetSystemUpdateID(Jamm::ui4& Id);
    void Browse(const std::string& ObjectID, const std::string& BrowseFlag, const std::string& Filter, const Jamm::ui4& StartingIndex, const Jamm::ui4& RequestedCount, const std::string& SortCriteria, std::string& Result, Jamm::ui4& NumberReturned, Jamm::ui4& TotalMatches, Jamm::ui4& UpdateID);
    void Search(const std::string& ContainerID, const std::string& SearchCriteria, const std::string& Filter, const Jamm::ui4& StartingIndex, const Jamm::ui4& RequestedCount, const std::string& SortCriteria, std::string& Result, Jamm::ui4& NumberReturned, Jamm::ui4& TotalMatches, Jamm::ui4& UpdateID);
    void CreateObject(const std::string& ContainerID, const std::string& Elements, std::string& ObjectID, std::string& Result);
    void DestroyObject(const std::string& ObjectID);
    void UpdateObject(const std::string& ObjectID, const std::string& CurrentTagValue, const std::string& NewTagValue);
    void ImportResource(const & SourceURI, const & DestinationURI, Jamm::ui4& TransferID);
    void GetTransferProgress(const Jamm::ui4& TransferID, std::string& TransferStatus, std::string& TransferLength, std::string& TransferTotal);
    void DeleteResource(const & ResourceURI);
    void CreateReference(const std::string& ContainerID, const std::string& ObjectID, std::string& NewID);

    void _reqGetSearchCapabilities();
    void _reqGetSortCapabilities();
    void _reqGetSystemUpdateID();
    void _reqBrowse(const std::string& ObjectID, const std::string& BrowseFlag, const std::string& Filter, const Jamm::ui4& StartingIndex, const Jamm::ui4& RequestedCount, const std::string& SortCriteria, );
    void _reqSearch(const std::string& ContainerID, const std::string& SearchCriteria, const std::string& Filter, const Jamm::ui4& StartingIndex, const Jamm::ui4& RequestedCount, const std::string& SortCriteria, );
    void _reqCreateObject(const std::string& ContainerID, const std::string& Elements, );
    void _reqDestroyObject(const std::string& ObjectID);
    void _reqUpdateObject(const std::string& ObjectID, const std::string& CurrentTagValue, const std::string& NewTagValue);
    void _reqImportResource(const & SourceURI, const & DestinationURI, );
    void _reqGetTransferProgress(const Jamm::ui4& TransferID, );
    void _reqDeleteResource(const & ResourceURI);
    void _reqCreateReference(const std::string& ContainerID, const std::string& ObjectID, );

    std::string _getTransferIDs();
    Jamm::ui4 _getSystemUpdateID();
    std::string _getContainerUpdateIDs();

protected:
    virtual void _ansGetSearchCapabilities(const std::string& SearchCaps) = 0;
    virtual void _ansGetSortCapabilities(const std::string& SortCaps) = 0;
    virtual void _ansGetSystemUpdateID(const Jamm::ui4& Id) = 0;
    virtual void _ansBrowse(const std::string& ObjectID, const std::string& BrowseFlag, const std::string& Filter, const Jamm::ui4& StartingIndex, const Jamm::ui4& RequestedCount, const std::string& SortCriteria, const std::string& Result, const Jamm::ui4& NumberReturned, const Jamm::ui4& TotalMatches, const Jamm::ui4& UpdateID) = 0;
    virtual void _ansSearch(const std::string& ContainerID, const std::string& SearchCriteria, const std::string& Filter, const Jamm::ui4& StartingIndex, const Jamm::ui4& RequestedCount, const std::string& SortCriteria, const std::string& Result, const Jamm::ui4& NumberReturned, const Jamm::ui4& TotalMatches, const Jamm::ui4& UpdateID) = 0;
    virtual void _ansCreateObject(const std::string& ContainerID, const std::string& Elements, const std::string& ObjectID, const std::string& Result) = 0;
    virtual void _ansDestroyObject(const std::string& ObjectID) = 0;
    virtual void _ansUpdateObject(const std::string& ObjectID, const std::string& CurrentTagValue, const std::string& NewTagValue) = 0;
    virtual void _ansImportResource(const & SourceURI, const & DestinationURI, const Jamm::ui4& TransferID) = 0;
    virtual void _ansGetTransferProgress(const Jamm::ui4& TransferID, const std::string& TransferStatus, const std::string& TransferLength, const std::string& TransferTotal) = 0;
    virtual void _ansDeleteResource(const & ResourceURI) = 0;
    virtual void _ansCreateReference(const std::string& ContainerID, const std::string& ObjectID, const std::string& NewID) = 0;

    virtual void _changedTransferIDs(const std::string& val) = 0;
    virtual void _changedSystemUpdateID(const Jamm::ui4& val) = 0;
    virtual void _changedContainerUpdateIDs(const std::string& val) = 0;

private:
    void _threadGetSearchCapabilities(Jamm::Action* pAction);
    void _threadGetSortCapabilities(Jamm::Action* pAction);
    void _threadGetSystemUpdateID(Jamm::Action* pAction);
    void _threadBrowse(Jamm::Action* pAction);
    void _threadSearch(Jamm::Action* pAction);
    void _threadCreateObject(Jamm::Action* pAction);
    void _threadDestroyObject(Jamm::Action* pAction);
    void _threadUpdateObject(Jamm::Action* pAction);
    void _threadImportResource(Jamm::Action* pAction);
    void _threadGetTransferProgress(Jamm::Action* pAction);
    void _threadDeleteResource(Jamm::Action* pAction);
    void _threadCreateReference(Jamm::Action* pAction);

    Jamm::Service* m_pService;
};


class MediaServerController : public Jamm::ControllerImplAdapter
{
public:
    MediaServerController(Jamm::Device* pDevice, ContentDirectoryController* pContentDirectoryController, ConnectionManagerController* pConnectionManagerController, AVTransportController* pAVTransportController);

    ContentDirectoryController* ContentDirectory() { return m_pContentDirectoryController; }
    ConnectionManagerController* ConnectionManager() { return m_pConnectionManagerController; }
    AVTransportController* AVTransport() { return m_pAVTransportController; }

private:
    virtual void eventHandler(Jamm::StateVar* pStateVar);

    Jamm::Device* m_pDevice;
    ContentDirectoryController* m_pContentDirectoryController;
    ConnectionManagerController* m_pConnectionManagerController;
    AVTransportController* m_pAVTransportController;
};

#endif

