/***************************************************************************|
|  Jamm - Just another multimedia ...                                       |
|         ... set of applications and libraries based on the UPnP-AV specs  |
|                                                                           |
|  Copyright (C) 2009                                                       |
|  Jörg Bakker (joerg'at'hakker'dot'de)                                     |
|                                                                           |
|  This file is part of Jamm.                                               |
|                                                                           |
|  Jamm is free software: you can redistribute it and/or modify             |
|  it under the terms of the GNU General Public License as published by     |
|  the Free Software Foundation version 3 of the License.                   |
|                                                                           |
|  Jamm is distributed in the hope that it will be useful,                  |
|  but WITHOUT ANY WARRANTY; without even the implied warranty of           |
|  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
|  GNU General Public License for more details.                             |
|                                                                           |
|  You should have received a copy of the GNU General Public License        |
|  along with this program.  If not, see <http://www.gnu.org/licenses/>.    |
 ***************************************************************************/

#include <Poco/String.h>

#include "jammgen.h"

std::string StubWriter::preamble = \
"\
/***************************************************************************|\n\
|  Jamm - Just another multimedia ...                                       |\n\
|         ... set of applications and libraries based on the UPnP-AV specs  |\n\
|                                                                           |\n\
|  Copyright (C) 2009                                                       |\n\
|  Jörg Bakker (joerg'at'hakker'dot'de)                                     |\n\
|                                                                           |\n\
|  This file is part of Jamm.                                               |\n\
|                                                                           |\n\
|  Jamm is free software: you can redistribute it and/or modify             |\n\
|  it under the terms of the GNU General Public License as published by     |\n\
|  the Free Software Foundation version 3 of the License.                   |\n\
|                                                                           |\n\
|  Jamm is distributed in the hope that it will be useful,                  |\n\
|  but WITHOUT ANY WARRANTY; without even the implied warranty of           |\n\
|  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |\n\
|  GNU General Public License for more details.                             |\n\
|                                                                           |\n\
|  You should have received a copy of the GNU General Public License        |\n\
|  along with this program.  If not, see <http://www.gnu.org/licenses/>.    |\n\
***************************************************************************/\n\
\n\
/***************************************************************************|\n\
|                               WARNING                                     |\n\
|        This file is generated by the jamm stub generator jammgen.         |\n\
|       Don't edit, it will be overriden at the next run of jammgen.        |\n\
***************************************************************************/\n\
\n\
";

std::string StubWriter::samplePreamble = \
"\
/***************************************************************************|\n\
|                               WARNING                                     |\n\
|        This file is generated by the jamm stub generator jammgen.         |\n\
|                   RENAME THIS FILE BEFORE EDITING!                        |\n\
|           It will be overriden at the next run of jammgen.                |\n\
***************************************************************************/\n\
\n\
";

StubWriter::StubWriter(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
m_pDeviceRoot(pDeviceRoot),
m_outputPath(outputPath)
{
    Jamm::Urn deviceType(pDeviceRoot->getRootDevice()->getDeviceType());
    m_deviceName = deviceType.getTypeName();
    m_outputPath += "/";
    
    m_typeMapper["boolean"] = "bool";
    m_typeMapper["ui1"] = "Jamm::ui1";
    m_typeMapper["ui2"] = "Jamm::ui2";
    m_typeMapper["ui4"] = "Jamm::ui4";
    m_typeMapper["i1"] = "Jamm::i1";
    m_typeMapper["i2"] = "Jamm::i2";
    m_typeMapper["i4"] = "Jamm::i4";
    m_typeMapper["r4"] = "Jamm::r4";
    m_typeMapper["r8"] = "Jamm::r8";
    m_typeMapper["number"] = "Jamm::number";
    m_typeMapper["string"] = "std::string";
}


void
StubWriter::write()
{
    deviceRoot(*m_pDeviceRoot);
    for (DeviceRoot::ServiceTypeIterator s = m_pDeviceRoot->beginServiceType(); s != m_pDeviceRoot->endServiceType(); ++s) {
        Service& rs = *((*s).second);
        serviceType(rs);
        for (Service::ActionIterator a = rs.beginAction(); a != rs.endAction(); ++a) {
            Action& ra = **a;
            action(ra);
            for (Action::ArgumentIterator arg = ra.beginArgument(); arg != ra.endArgument(); ++arg) {
                int dist = distance(arg, ra.endArgument());
                Argument& rarg = **arg;
                argument(rarg, dist == 1);
            }
            actionEnd(ra);
        }
        actionBlockEnd();
        for (Service::StateVarIterator sv = rs.beginStateVar(); sv != rs.endStateVar(); ++sv) {
            StateVar& rsv = **sv;
            stateVar(rsv);
        }
        serviceTypeEnd(rs);
    }
    deviceRootEnd(*m_pDeviceRoot);
}


std::string
StubWriter::indent(int level)
{
    std::string res = "";
    while(level--) {
        res += "    ";
    }
    return res;
}


std::string
StubWriter::firstLetterToLower(const std::string& s)
{
    return Poco::toLower(s.substr(0, 1)) + s.substr(1);
}


DeviceH::DeviceH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
m_out((m_outputPath + m_deviceName + ".h").c_str())
{
}


void
DeviceH::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << preamble
        << "#ifndef " << Poco::toUpper(m_deviceName) << "_H" << std::endl
        << "#define " << Poco::toUpper(m_deviceName) << "_H" << std::endl
        << std::endl
        << "#include <jamm/upnp.h>" << std::endl
        << std::endl
        << "using Jamm::DeviceRootImplAdapter;" << std::endl
        << "using Jamm::Service;" << std::endl
        << "using Jamm::Action;" << std::endl
        << std::endl
        << "class " << m_deviceName << ";"
        << std::endl;
}


void
DeviceH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string ctorArgs = "";
//     std::string implPointers = "";
    int i = m_serviceNames.size();
    while (i--) {
        ctorArgs += m_serviceNames[i] + "* p" + m_serviceNames[i] + "Impl" + (i ? ", " : "");
    }
    
    m_out << std::endl
        << "class " << m_deviceName << " : public DeviceRootImplAdapter" << std::endl
        << "{" << std::endl
        << "public:" << std::endl
        << indent(1) << m_deviceName << "("
        << ctorArgs
        << ");" << std::endl
        << std::endl;
//         << "private:"
//         << std::endl;
    
    m_out <<  std::endl
        << "private:" << std::endl
        << indent(1) << "virtual void actionHandler(Action* action);" << std::endl
        << indent(1) << "virtual void initStateVars(const std::string& serviceType, Service* pThis);" << std::endl
        << std::endl
        << indent(1) << "static std::string m_deviceDescription;" << std::endl
        ;
    
    i = m_serviceNames.size();
    while (i--) {
        m_out << indent(1) << m_serviceNames[i] << "* m_p" << m_serviceNames[i] << "Impl;" << std::endl;
    }
    
    m_out
        << "};" << std::endl
        << std::endl
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceH::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    m_serviceNames.push_back(serviceName);
    
    m_out << std::endl
        << "class " << serviceName << std::endl
        << "{" << std::endl
        << indent(1) << "friend class " << m_deviceName << ";" << std::endl
        << std::endl
        << "protected:"
        << std::endl;
}


void
DeviceH::serviceTypeEnd(const Service& service)
{
    m_out << std::endl
        << "private:" << std::endl
        << indent(1) << "static std::string  m_description;" << std::endl
        << indent(1) << "Service* m_pService;" << std::endl
        << "};" << std::endl
        << std::endl;
}


void
DeviceH::action(const Action& action)
{
    m_out
        << indent(1) << "virtual void " << action.getName() << "("
        ;
}


void
DeviceH::actionEnd(const Action& action)
{
    m_out
        << ") = 0;"
        << std::endl;
}


void
DeviceH::actionBlockEnd()
{
    m_out << std::endl
        << indent(1) << "virtual void initStateVars() = 0;" << std::endl
        << std::endl;
}


void
DeviceH::argument(const Argument& argument, bool lastArgument)
{
    m_out
        << ((argument.getDirection() == "in") ? "const " : "")
        << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceH::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    m_out
        << indent(1) << "void _set" << stateVar.getName() << "(const "
        << m_typeMapper[stateVar.getType()] << "& val);"
        << std::endl
        << indent(1) << m_typeMapper[stateVar.getType()]
        << " _get" << stateVar.getName() << "();"
        << std::endl;
}


DeviceCpp::DeviceCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
m_out((m_outputPath + m_deviceName + ".cpp").c_str())
// m_out(&std::cout)
{
}


void
DeviceCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << preamble
        << "#include <jamm/upnp.h>" << std::endl
        << "#include \"" << m_deviceName << ".h\"" << std::endl
        << "#include \"" << m_deviceName << "Descriptions.h\"" << std::endl
        << std::endl
        << std::endl
        << "void" << std::endl
        << m_deviceName << "::actionHandler(Action* pAction)" << std::endl
        << "{" << std::endl
        << indent(1) << "// the great action dispatcher" << std::endl;
    
    m_stateVarInitializer
        << "void" << std::endl
        << m_deviceName << "::initStateVars(const std::string& serviceType, Service* pThis)" << std::endl
        << "{"
        << std::endl;
}


void
DeviceCpp::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string deviceDescriptionPath = deviceRoot.getDescriptionUri().getPath();
    std::string ctorArgs = "";
    int i = m_serviceNames.size();
    while (i--) {
        ctorArgs += m_serviceNames[i] + "* p" + m_serviceNames[i] + "Impl" + (i ? ", " : "");
    }
    m_firstService = true;
    
    m_out
        << "}" << std::endl
        << std::endl
        << std::endl
        << m_stateVarInitializer.str()
        << "}" << std::endl
        << std::endl
        << std::endl
        << m_deviceName << "::" << m_deviceName << "("
        << ctorArgs
        << ") :" << std::endl
        << "DeviceRootImplAdapter()," << std::endl
        ;
    
    i = m_serviceNames.size();
    while (i--) {
        m_out 
            << "m_p" << m_serviceNames[i] << "Impl(p" << m_serviceNames[i] << "Impl)"
            << (i ? ", " : "") << std::endl;
    }
    
    m_out
        << "{" << std::endl
        << indent(1) << "m_descriptions[\"" << deviceDescriptionPath << "\"]"
        << " = &" << m_deviceName << "::m_deviceDescription;" << std::endl;
    
    i = m_serviceNames.size();
    while (i--) {
        m_out
            << indent(1) << "m_descriptions[\"" << m_servicePaths[i] << "\"]"
            << " = &" << m_serviceNames[i] << "::m_description;" << std::endl;
    }
    
//     m_out << std::endl;
//     
//     i = m_serviceNames.size();
//     while (i--) {
//         m_out
//             << indent(1) << "p" << m_serviceNames[i] << "Impl->m_pMediaRenderer = this;"
//             << std::endl;
//     }
    
    m_out << std::endl
        << indent(1) << "Jamm::StringDescriptionReader descriptionReader(m_descriptions, \""
        << deviceDescriptionPath << "\");" << std::endl
        << indent(1) << "m_pDeviceRoot = descriptionReader.deviceRoot();" << std::endl
        << indent(1) << "m_pDeviceRoot->setImplAdapter(this);" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl
        << m_getSet.str()
        << std::endl;
}


void
DeviceCpp::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    m_serviceNames.push_back(serviceName);
    m_currentService = serviceName;
    m_servicePaths.push_back(service.getDescriptionPath());
    m_firstAction = true;
    
    m_out
        << indent(1) << (m_firstService ? "" : "else ")
        << "if (pAction->getService()->getServiceType() == \""
        << service.getServiceType() << "\") {" << std::endl
        << indent(2) << "m_p" << serviceName << "Impl->m_pService = pAction->getService();" << std::endl
        << indent(2) << "std::string actionName = pAction->getName();" << std::endl
        << std::endl;
    
    m_stateVarInitializer
        << indent(1) << (m_firstService ? "" : "else ")
        << "if (serviceType == \"" << service.getServiceType() << "\") {" << std::endl
        << indent(2) << "m_p" << serviceName << "Impl->m_pService = pThis;" << std::endl
        << indent(2) << "m_p" << serviceName << "Impl->initStateVars();" << std::endl
        << indent(1) << "}" << std::endl;
    
    m_firstService = false;
}


void
DeviceCpp::serviceTypeEnd(const Service& service)
{
    m_out
        << indent(1) << "}"
        << std::endl;
}


void
DeviceCpp::action(const Action& action)
{
    m_out
        << indent(2) << (m_firstAction ? "" : "else ")
        << "if (actionName == \"" << action.getName() << "\") {" << std::endl
        ;
    m_currentOutArgs = "";
    m_currentOutArgSetter.str("");
    m_firstAction = false;
}


void
DeviceCpp::actionEnd(const Action& action)
{
    m_out
        // do the implementation callback here
        << indent(3) << "m_p" << m_currentService << "Impl->" << action.getName()
        << "(" << m_currentOutArgs << ");" << std::endl
        << m_currentOutArgSetter.str()
        << indent(2) << "}"
        << std::endl;
}


void
DeviceCpp::argument(const Argument& argument, bool lastArgument)
{
    std::string argType = m_typeMapper[argument.getRelatedStateVarReference()->getType()];
    m_out
        << indent(3) << argType
        << " " /*<< argument.getDirection()*/ << argument.getName();
    if (argument.getDirection() == "in") {
        m_out <<
            " = pAction->getArgument<" << argType << ">(\"" << argument.getName() << "\")";
    }
    m_out
        << ";" << std::endl;
    m_currentOutArgs += /*(argument.getDirection() == "in" ? "const " : "")*/
//         + argType + "& "
        /*+ */argument.getName()
        + (lastArgument ? "" : ", ");
    if (argument.getDirection() == "out") {
        m_currentOutArgSetter
            << indent(3) << "pAction->setArgument<"
            << argType << ">(\"" << argument.getName()
            << "\", " << argument.getName() 
            << ");" << std::endl;
    }
}


void
DeviceCpp::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    std::string stateVarType = m_typeMapper[stateVar.getType()];
    m_getSet
        // StateVar setter method
        << "void" << std::endl
        << m_currentService << "::_set" << stateVar.getName() 
        << "(const " << stateVarType << "& val)" << std::endl
        << "{" << std::endl
        << indent(1) << "m_pService->setStateVar<" << stateVarType 
        << ">(\"" << stateVar.getName() << "\", val);" << std::endl
        << "}" << std::endl
        << std::endl
        << stateVarType << std::endl
        
        // StateVar getter method
        << m_currentService << "::_get" << stateVar.getName() 
        << "()" << std::endl
        << "{" << std::endl
        << indent(1) << "return m_pService->getStateVar<" << stateVarType 
        << ">(\"" << stateVar.getName() << "\");" << std::endl
        << "}" << std::endl
        << std::endl;
}


DeviceImplH::DeviceImplH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
m_out((m_outputPath + m_deviceName + "Impl.h.sample").c_str())
{
}


void
DeviceImplH::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << samplePreamble
        << "#ifndef " << Poco::toUpper(m_deviceName) << "_IMPLEMENTATION_H" << std::endl
        << "#define " << Poco::toUpper(m_deviceName) << "_IMPLEMENTATION_H" << std::endl
        << std::endl
        << "#include <jamm/upnp.h>" << std::endl
        << "#include \"" << m_deviceName << ".h\"" << std::endl
        << std::endl;
}


void
DeviceImplH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    m_out
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceImplH::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();

    m_out
        << "class " << serviceName << "Implementation : public " << serviceName << std::endl
        << "{" << std::endl
//         << "public:" << std::endl
//         << serviceName << "Implementation();" << std::endl
//         << std::endl
        << "private:"
        << std::endl;
}


void
DeviceImplH::serviceTypeEnd(const Service& service)
{
    m_out
        << std::endl
        << indent(1) << "virtual void initStateVars();" << std::endl
//         << std::endl
//         << indent(1) << deviceName << "Implementation* m_pDeviceImpl;" << std::endl
//         << std::endl
        << "};" << std::endl
        << std::endl;
}


void
DeviceImplH::action(const Action& action)
{
    m_out
        << indent(1) << "virtual void " << action.getName() << "("
        ;
}


void
DeviceImplH::actionEnd(const Action& action)
{
    m_out
        << ");"
        << std::endl;
}


void
DeviceImplH::argument(const Argument& argument, bool lastArgument)
{
    m_out
        << ((argument.getDirection() == "in") ? "const " : "")
        << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


DeviceImplCpp::DeviceImplCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
m_out((m_outputPath + m_deviceName + "Impl.cpp.sample").c_str())
{
}


void
DeviceImplCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << samplePreamble
        << "#include <jamm/upnp.h>" << std::endl
        << "#include \"" << m_deviceName << "Impl.h\"" << std::endl
        << std::endl;
}


void
DeviceImplCpp::serviceType(const Service& service)
{
    m_serviceName = Jamm::Urn(service.getServiceType()).getTypeName();
    m_out
        << "void" << std::endl
        << m_serviceName << "Implementation::initStateVars()" << std::endl
        << "{" << std::endl
        << "// you may set state variables here with the _set<state_variable_name>() methods" << std::endl
        << "// default values are already set, if defined by the service" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}


void
DeviceImplCpp::action(const Action& action)
{
    m_out
        << "void" << std::endl << m_serviceName << "Implementation::" << action.getName() 
        << "(";
}


void
DeviceImplCpp::actionEnd(const Action& action)
{
    m_out
        << ")" << std::endl
        << "{" << std::endl
        << "// begin of your own code" << std::endl
        << std::endl
        << "// end of your own code" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}


void
DeviceImplCpp::argument(const Argument& argument, bool lastArgument)
{
    m_out
        << ((argument.getDirection() == "in") ? "const " : "")
        << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


DeviceDescH::DeviceDescH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
m_out((m_outputPath + m_deviceName + "Descriptions.h").c_str())
{
}


void
DeviceDescH::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << preamble
        << "#ifndef " << Poco::toUpper(m_deviceName) << "_DESCRIPTIONS_H" << std::endl
        << "#define " << Poco::toUpper(m_deviceName) << "_DESCRIPTIONS_H" << std::endl
        << std::endl
        << "std::string " << m_deviceName << "::m_deviceDescription =" << std::endl
        << escapeDescription(deviceRoot.getDeviceDescription())
        << ";" << std::endl
        << std::endl;
}


void
DeviceDescH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    m_out
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceDescH::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    
    m_out
        << "std::string " << serviceName << "::m_description =" << std::endl
        << escapeDescription(service.getDescription())
        << ";" << std::endl
        << std::endl;
}


std::string
DeviceDescH::escapeDescription(const std::string& description)
{
    std::string res = description;
    
    // escape all quotes
    std::string::size_type i = 0;
    while ((i = res.find("\"", i)) != std::string::npos) {
        res.insert(i, "\\");
        ++i; ++i;
    }
    
    // delete all carriage returns
    i = 0;
    while ((i = res.find("\r", i)) != std::string::npos) {
        res.erase(i, 1);
    }
    
    // escape all newlines
    i = 0;
    while ((i = res.find("\n", i)) != std::string::npos) {
        res.insert(i, "\\");
        ++i; ++i;
    }
    
    return "\"" + res + "\"";
}


DeviceCtrlImplH::DeviceCtrlImplH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
// m_out(&std::cout)
m_out((m_outputPath + m_deviceName + "CtrlImpl.h.sample").c_str())
{
}


void
DeviceCtrlImplH::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << samplePreamble
        << "#ifndef " << Poco::toUpper(m_deviceName) << "_CTRL_IMPL_H" << std::endl
        << "#define " << Poco::toUpper(m_deviceName) << "_CTRL_IMPL_H" << std::endl
        << std::endl
        << "#include <jamm/upnp.h>" << std::endl
        << "#include \"" << m_deviceName << "Ctrl.h\"" << std::endl
        << std::endl;
}


void
DeviceCtrlImplH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    m_out
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceCtrlImplH::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    
    m_out
        << "class " << serviceName << "ControllerImpl : public " << serviceName << "Controller" << std::endl
        << "{" << std::endl
        << "private:"
        << std::endl;
}


void
DeviceCtrlImplH::serviceTypeEnd(const Service& service)
{
    m_out
        << std::endl
        << m_eventedStateVars.str()
        << "};" << std::endl
        << std::endl;
    
    m_eventedStateVars.str("");
}


void
DeviceCtrlImplH::action(const Action& action)
{
    m_out
        << indent(1) << "virtual void _ans" << action.getName() << "("
        ;
}


void
DeviceCtrlImplH::actionEnd(const Action& action)
{
    m_out
        << ");"
        << std::endl;
}


void
DeviceCtrlImplH::argument(const Argument& argument, bool lastArgument)
{
    m_out
        << "const "
        << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceCtrlImplH::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
    m_eventedStateVars
        << indent(1) << "virtual void _changed" << stateVar.getName() << "(const "
        << m_typeMapper[stateVar.getType()] << "& val);"
        << std::endl;
}


DeviceCtrlImplCpp::DeviceCtrlImplCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
// m_out(&std::cout)
m_out((m_outputPath + m_deviceName + "CtrlImpl.cpp.sample").c_str())
{
}


void
DeviceCtrlImplCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << samplePreamble
        << "#include \"" << m_deviceName << "CtrlImpl.h\"" << std::endl
        << std::endl;
}


void
DeviceCtrlImplCpp::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    m_serviceName = serviceType.getTypeName();
}


void
DeviceCtrlImplCpp::argument(const Argument& argument, bool lastArgument)
{
    m_out
        << "const "
        << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceCtrlImplCpp::action(const Action& action)
{
    m_out
        << "void" << std::endl 
        << m_serviceName << "ControllerImpl::_ans" << action.getName() 
        << "(";
}


void
DeviceCtrlImplCpp::actionEnd(const Action& action)
{
    m_out
        << ")" << std::endl
        << "{" << std::endl
        << "// begin of your own code" << std::endl
        << std::endl
        << "// end of your own code" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}


void
DeviceCtrlImplCpp::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
    m_out
        << "void" << std::endl 
        << m_serviceName << "ControllerImpl::_changed" << stateVar.getName() << "(const "
        << m_typeMapper[stateVar.getType()] << "& val)" << std::endl
        << "{" << std::endl
        << "// begin of your own code" << std::endl
        << std::endl
        << "// end of your own code" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}



DeviceCtrlH::DeviceCtrlH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
m_out((m_outputPath + m_deviceName + "Ctrl.h").c_str())
{
}


void
DeviceCtrlH::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << preamble
        << "#ifndef " << Poco::toUpper(m_deviceName) << "_CTRL_H" << std::endl
        << "#define " << Poco::toUpper(m_deviceName) << "_CTRL_H" << std::endl
        << std::endl
        << "#include <jamm/upnp.h>" << std::endl
        << std::endl;
}


void
DeviceCtrlH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string ctorArgs = "";
    int i = m_serviceNames.size();
    while (i--) {
        ctorArgs += m_serviceNames[i] + "Controller* p" + m_serviceNames[i] + "Controller" + (i ? ", " : "");
    }
    
    m_out << std::endl
        << "class " << m_deviceName << "Controller : public Jamm::ControllerImplAdapter" << std::endl
        << "{" << std::endl
        << "public:" << std::endl
        << indent(1) << m_deviceName << "Controller("
        << "Jamm::Device* pDevice, "
        << ctorArgs
        << ");" << std::endl
        << std::endl;
    
    i = m_serviceNames.size();
    while (i--) {
        m_out << indent(1)
            << m_serviceNames[i] << "Controller* " << m_serviceNames[i] 
            << "() { return m_p" << m_serviceNames[i] << "Controller; }"
            << std::endl;
    }
    
    m_out <<  std::endl
        << "private:" << std::endl
        << indent(1) << "virtual void eventHandler(Jamm::StateVar* pStateVar);" << std::endl
        << std::endl
        << indent(1) << "Jamm::Device* m_pDevice;" << std::endl
        ;
    
    i = m_serviceNames.size();
    while (i--) {
        m_out << indent(1) << m_serviceNames[i] << "Controller* m_p" << m_serviceNames[i] << "Controller;" << std::endl;
    }
    
    m_out
        << "};" << std::endl
        << std::endl
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceCtrlH::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    m_serviceNames.push_back(serviceName);
    
    m_out
        << "class " << serviceName << "Controller" << std::endl
        << "{" << std::endl
        << indent(1) << "friend class " << m_deviceName << "Controller;" << std::endl
        << std::endl
        << "public:"
        << std::endl;
}


void
DeviceCtrlH::serviceTypeEnd(const Service& service)
{
    m_out
        << std::endl
        << m_reqAction.str()
        << std::endl
        << m_getEventedStateVars.str()
        << std::endl
        << "protected:" << std::endl
        << m_ansAction.str()
        << std::endl
        << m_changeEventedStateVars.str()
        << std::endl
        << "private:" << std::endl
        << m_threadAction.str()
        << std::endl
        << indent(1) << "Jamm::Service* m_pService;" << std::endl
        << "};" << std::endl
        << std::endl;
    
    m_reqAction.str("");
    m_ansAction.str("");
    m_threadAction.str("");
    m_getEventedStateVars.str("");
    m_changeEventedStateVars.str("");
}


void
DeviceCtrlH::action(const Action& action)
{
    m_out
        << indent(1) << "void " << action.getName() << "("
        ;
    m_reqAction
        << indent(1) << "void _req" << action.getName() << "("
        ;
    m_ansAction
        << indent(1) << "virtual void _ans" << action.getName() << "("
        ;
    m_threadAction
        << indent(1) << "void _thread" << action.getName() << "("
        ;
}


void
DeviceCtrlH::actionEnd(const Action& action)
{
    m_out
        << ");"
        << std::endl;
    m_reqAction
        << m_reqActionArgs.str()
        << ");"
        << std::endl;
    m_ansAction
        << m_ansActionArgs.str()
        << ") = 0;"
        << std::endl;
    m_threadAction
        << "Jamm::Action* pAction);"
        << std::endl;
    
    m_reqActionArgs.str("");
    m_ansActionArgs.str("");
}


void
DeviceCtrlH::argument(const Argument& argument, bool lastArgument)
{
    m_out
        << ((argument.getDirection() == "in") ? "const " : "")
        << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
    
    if (argument.getDirection() == "in") {
        m_reqActionArgs
            << "const "
            << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
            << "& " << argument.getName()
            << (lastArgument ? "" : ", ")
            ;
    }
    
    m_ansActionArgs
        << "const "
        << m_typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceCtrlH::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
    m_getEventedStateVars
        << indent(1)
        << m_typeMapper[stateVar.getType()] << " "
        << "_get" << stateVar.getName() << "();"
        << std::endl;
    
    m_changeEventedStateVars
        << indent(1) << "virtual void _changed" << stateVar.getName() << "(const "
        << m_typeMapper[stateVar.getType()] << "& val) = 0;"
        << std::endl;
}


DeviceCtrlCpp::DeviceCtrlCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
m_out((m_outputPath + m_deviceName + "Ctrl.cpp").c_str())
{
}


void
DeviceCtrlCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    m_out
        << preamble
        << "#include \"" << m_deviceName << "Ctrl.h\"" << std::endl
        << std::endl;
    
    m_firstStateVar = true;
}


void
DeviceCtrlCpp::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string ctorArgs = "";
//     std::string implPointers = "";
    int i = m_serviceNames.size();
    while (i--) {
        ctorArgs += m_serviceNames[i] + "Controller* p" + m_serviceNames[i] + "Controller" + (i ? ", " : "");
    }
    
    // Event dispatcher
    
    m_out
        << "void" << std::endl
        << m_deviceName << "Controller::eventHandler(Jamm::StateVar* pStateVar)" << std::endl
        << "{" << std::endl
        << m_eventDispatcher.str()
        << "}" << std::endl
        << std::endl;
    
    // Device ctor ...
    m_out << std::endl
//         << "class " << m_deviceName << "Controller : public Jamm::ControllerImplAdapter" << std::endl
//         << "{" << std::endl
//         << "public:" << std::endl
        << m_deviceName << "Controller" << "::" << m_deviceName << "Controller" << "("
        << "Jamm::Device* pDevice, "
        << ctorArgs
        << ") :" << std::endl
        << "ControllerImplAdapter(pDevice)," << std::endl
        << "m_pDevice(pDevice)," << std::endl;
    
    i = m_serviceNames.size();
    while (i--) {
        m_out
            << "m_p" << m_serviceNames[i] << "Controller(p" 
            << m_serviceNames[i] << "Controller)" <<  (i ? ", " : "") << std::endl;
    }
    
    m_out
        << "{" << std::endl;
    
    i = m_serviceNames.size();
    while (i--) {
        m_out
                    
            << indent(1) << "m_p" << m_serviceNames[i] << "Controller->m_pService = "
            << "m_pDevice->getService(\"" << m_serviceTypes[i] << "\");"
            << std::endl;
    }
    
    m_out
        << std::endl
        << indent(1) << "init();" << std::endl
        << "}" << std::endl
        << std::endl;
    
//     i = m_serviceNames.size();
//     while (i--) {
//         m_out << indent(1)
//             << m_serviceNames[i] << "Controller* " << m_serviceNames[i] 
//             << "() { return m_p" << m_serviceNames[i] << "Controller; }"
//             << std::endl;
//     }
//     
//     m_out <<  std::endl
//         << "private:" << std::endl
//         << indent(1) << "virtual void eventHandler(Jamm::StateVar* pStateVar);" << std::endl
//         << std::endl
//         << indent(1) << "Jamm::Device* m_pDevice;" << std::endl
//         ;
//     
//     i = m_serviceNames.size();
//     while (i--) {
//         m_out << indent(1) << m_serviceNames[i] << "Controller* m_p" << m_serviceNames[i] << "Controller;" << std::endl;
//     }
//     
//     m_out
//         << "};" << std::endl
//         << std::endl
//         << "#endif" << std::endl
//         << std::endl;
}


void
DeviceCtrlCpp::serviceType(const Service& service)
{
    Jamm::Urn serviceType(service.getServiceType());
    m_serviceTypes.push_back(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    m_serviceNames.push_back(serviceName);
    m_currentService = serviceName;
}


void
DeviceCtrlCpp::serviceTypeEnd(const Service& service)
{
    m_out
        << std::endl
        << m_reqAction.str()
//         << std::endl
/*        << m_getEventedStateVars.str()
        << std::endl
        << "protected:" << std::endl
        << m_ansAction.str()
        << std::endl
        << m_changeEventedStateVars.str()
        << std::endl
        << "private:" << std::endl*/
        << m_threadAction.str()
        << std::endl
//         << indent(1) << "Service* m_pService;" << std::endl
//         << "};" << std::endl
        << std::endl;
    
    m_reqAction.str("");
//     m_ansAction.str("");
    m_threadAction.str("");
//     m_getEventedStateVars.str("");
//     m_changeEventedStateVars.str("");
}


void
DeviceCtrlCpp::action(const Action& action)
{
    m_out
        << "void" << std::endl
        << m_currentService << "Controller::" << action.getName() << "("
        ;
    m_reqAction
        << "void " << std::endl
        << m_currentService << "Controller::_req" << action.getName() << "("
        ;
    m_threadAction
        << "void " << std::endl
        << m_currentService << "Controller::_thread" << action.getName() << "("
        << "Jamm::Action* pAction"
        ;
}


void
DeviceCtrlCpp::actionEnd(const Action& action)
{
    m_out
        << ")" << std::endl
        << "{" << std::endl
        << indent(1) << "Jamm::Action* pAction = m_pService->getAction(\"" 
        << action.getName() << "\")->clone();" << std::endl
        << m_inArgSetter.str()
        << indent(1) << "m_pService->sendAction(pAction);" << std::endl
        << m_outArgGetter.str()
        << "}" << std::endl
        << std::endl;
    
    m_reqAction
        << m_reqActionArgs.str()
        << ")" << std::endl
        << "{" << std::endl
        << indent(1) << "Jamm::Action* pAction = m_pService->getAction(\"" 
        << action.getName() << "\")->clone();" << std::endl
        << m_inArgSetter.str()
        << indent(1) << "Jamm::ActionThread<"
        << m_currentService << "Controller> thread(this, &"
        << m_currentService << "Controller::_thread" << action.getName() << ", pAction);" << std::endl
        << indent(1) << "thread.start();" << std::endl
        << "}" << std::endl
        << std::endl;

    m_threadAction
        << ")" << std::endl
        << "{" << std::endl
        << indent(1) << "m_pService->sendAction(pAction);" << std::endl
        << m_inArgGetter.str()
        << m_outArgGetterLocal.str()
        << indent(1) << "_ans" << action.getName() << "(" << m_allArgsCall.str() << ");" << std::endl
        << "}" << std::endl
        << std::endl;
    
    m_inArgSetter.str("");
    m_inArgGetter.str("");
    m_outArgGetter.str("");
    m_outArgGetterLocal.str("");
    m_reqActionArgs.str("");
    m_allArgsCall.str("");
}


void
DeviceCtrlCpp::argument(const Argument& argument, bool lastArgument)
{
    std::string argType = m_typeMapper[argument.getRelatedStateVarReference()->getType()];
    
    m_out
        << ((argument.getDirection() == "in") ? "const " : "")
        << argType
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
    
    m_allArgsCall
        << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
    
    if (argument.getDirection() == "in") {
        m_inArgSetter
            << indent(1) << "pAction->setArgument<" << argType << ">(\""
            << argument.getName() << "\", "
            << argument.getName() << ");"
            << std::endl;
        
        m_inArgGetter
            << indent(1) << argType << " " << argument.getName()
            << " = pAction->getArgument<" << argType << ">(\""
            << argument.getName() << "\");"
            << std::endl;
        
        m_reqActionArgs
            << "const "
            << argType
            << "& " << argument.getName()
            << (lastArgument ? "" : ", ")
            ;
    }
    else if (argument.getDirection() == "out") {
        m_outArgGetter
            << indent(1) << argument.getName()
            << " = pAction->getArgument<" << argType << ">(\""
            << argument.getName() << "\");"
            << std::endl;
        
        m_outArgGetterLocal
            << indent(1) << argType << " " << argument.getName()
            << " = pAction->getArgument<" << argType << ">(\""
            << argument.getName() << "\");"
            << std::endl;
    }
    
//     if (argument.getDirection() == "in") {
//     }
    
//     m_ansActionArgs
//         << "const "
//         << argType
//         << "& " << argument.getName()
//         << (lastArgument ? "" : ", ")
//         ;
}


void
DeviceCtrlCpp::stateVar(const StateVar& stateVar)
{
    std::string varType = m_typeMapper[stateVar.getType()];
    
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
//     m_getEventedStateVars
//         << indent(1)
//         << varType << " "
//         << "_get" << stateVar.getName() << "();"
//         << std::endl;
//     
//     m_changeEventedStateVars
//         << indent(1) << "virtual void _changed" << stateVar.getName() << "(const "
//         << varType << "& val) = 0;"
//         << std::endl;
    
    m_eventDispatcher
        << indent(1) << (m_firstStateVar ? "" : "else ")
        << "if (pStateVar->getName() == \"" << stateVar.getName() << "\") {" << std::endl
        << indent(2) << varType << " val;" << std::endl
        << indent(2) << "pStateVar->getValue(val);" << std::endl
        << indent(2) << "m_p" << m_currentService << "Controller->_changed" << stateVar.getName() << "(val);" << std::endl
        << indent(1) << "}" << std::endl;
    
    m_out
        << varType << std::endl
        << m_currentService << "Controller::_get" << stateVar.getName() << "()" << std::endl
        << "{" << std::endl
        << indent(1) << "return m_pService->getStateVar<" << varType << ">(\"" << stateVar.getName() << "\");" << std::endl
        << "}" << std::endl
        << std::endl;
    
    m_firstStateVar = false;
}