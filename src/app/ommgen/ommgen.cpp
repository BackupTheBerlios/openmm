/***************************************************************************|
|  OMM - Open Multimedia                                                    |
|                                                                           |
|  Copyright (C) 2009, 2010, 2011                                           |
|  Jörg Bakker (jb'at'open-multimedia.org)                                  |
|                                                                           |
|  This file is part of OMM.                                                |
|                                                                           |
|  OMM is free software: you can redistribute it and/or modify              |
|  it under the terms of the GNU General Public License as published by     |
|  the Free Software Foundation version 3 of the License.                   |
|                                                                           |
|  OMM is distributed in the hope that it will be useful,                   |
|  but WITHOUT ANY WARRANTY; without even the implied warranty of           |
|  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
|  GNU General Public License for more details.                             |
|                                                                           |
|  You should have received a copy of the GNU General Public License        |
|  along with this program.  If not, see <http://www.gnu.org/licenses/>.    |
 ***************************************************************************/

#include <Poco/String.h>

#include "ommgen.h"

std::string StubWriter::preamble = \
"\
/***************************************************************************|\n\
|  OMM - Open Multimedia                                                    |\n\
|                                                                           |\n\
|  Copyright (C) 2009, 2010, 2011                                           |\n\
|  Jörg Bakker (jb'at'open-multimedia.org)                                  |\n\
|                                                                           |\n\
|  This file is part of OMM.                                                |\n\
|                                                                           |\n\
|  OMM is free software: you can redistribute it and/or modify              |\n\
|  it under the terms of the GNU General Public License as published by     |\n\
|  the Free Software Foundation version 3 of the License.                   |\n\
|                                                                           |\n\
|  OMM is distributed in the hope that it will be useful,                   |\n\
|  but WITHOUT ANY WARRANTY; without even the implied warranty of           |\n\
|  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |\n\
|  GNU General Public License for more details.                             |\n\
|                                                                           |\n\
|  You should have received a copy of the GNU General Public License        |\n\
|  along with this program.  If not, see <http://www.gnu.org/licenses/>.    |\n\
***************************************************************************/\n\
\n\
/***************************************************************************|\n\
|                               WARNING                                     |\n\
|        This file is generated by the OMM stub generator ommgen.           |\n\
|       Don't edit, it will be overriden at the next run of ommgen.         |\n\
****************************************************************************/\n\
\n\
";

std::string StubWriter::samplePreamble = \
"\
/***************************************************************************|\n\
|                               WARNING                                     |\n\
|        This file is generated by the omm stub generator ommgen.         |\n\
|                   RENAME THIS FILE BEFORE EDITING!                        |\n\
|           It will be overriden at the next run of ommgen.                |\n\
***************************************************************************/\n\
\n\
";

StubWriter::StubWriter(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
_pDeviceRoot(pDeviceRoot),
_outputPath(outputPath)
{
    std::clog << "ctor stub writer";
    
    Omm::Urn deviceType(pDeviceRoot->getRootDevice()->getDeviceType());
    _deviceName = deviceType.getTypeName();
    _outputPath += "/";

    std::clog << "device name: " << _deviceName << ", output path: " << _outputPath << std::endl;
    
    _typeMapper["boolean"] = "bool";
    _typeMapper["ui1"] = "Omm::ui1";
    _typeMapper["ui2"] = "Omm::ui2";
    _typeMapper["ui4"] = "Omm::ui4";
    _typeMapper["i1"] = "Omm::i1";
    _typeMapper["i2"] = "Omm::i2";
    _typeMapper["i4"] = "Omm::i4";
    _typeMapper["r4"] = "Omm::r4";
    _typeMapper["r8"] = "Omm::r8";
    _typeMapper["number"] = "Omm::number";
    _typeMapper["string"] = "std::string";
    _typeMapper["uri"] = "Omm::uri";
}


void
StubWriter::write()
{
    std::clog << "writing: " << _outputPath + "/" + _deviceName << std::endl;

    deviceRoot(*_pDeviceRoot);
    for (DeviceRoot::ServiceTypeIterator s = _pDeviceRoot->beginServiceType(); s != _pDeviceRoot->endServiceType(); ++s) {
        Service& rs = *((*s).second);
        serviceType(rs);
        for (Service::ActionIterator a = rs.beginAction(); a != rs.endAction(); ++a) {
            Action& ra = **a;
            action(ra);
            for (Action::ArgumentIterator arg = ra.beginArgument(); arg != ra.endArgument(); ++arg) {
                int dist = distance(arg, ra.endArgument());
                Argument& rarg = **arg;
                argument(rarg, dist == 1);
            }
            actionEnd(ra);
        }
        actionBlockEnd();
        for (Service::StateVarIterator sv = rs.beginStateVar(); sv != rs.endStateVar(); ++sv) {
            StateVar& rsv = **sv;
            stateVar(rsv);
        }
        serviceTypeEnd(rs);
    }
    deviceRootEnd(*_pDeviceRoot);
}


std::string
StubWriter::indent(int level)
{
    std::string res = "";
    while(level--) {
        res += "    ";
    }
    return res;
}


std::string
StubWriter::firstLetterToLower(const std::string& s)
{
    return Poco::toLower(s.substr(0, 1)) + s.substr(1);
}


DeviceH::DeviceH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + ".h").c_str())
{
}


void
DeviceH::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << preamble
        << "#ifndef " << Poco::toUpper(_deviceName) << "_H" << std::endl
        << "#define " << Poco::toUpper(_deviceName) << "_H" << std::endl
        << std::endl
        << "#include <omm/upnp.h>" << std::endl
        << std::endl
        << "using Omm::DeviceRootImplAdapter;" << std::endl
        << "using Omm::Service;" << std::endl
        << "using Omm::Action;" << std::endl
        << std::endl
        << "class " << _deviceName << ";"
        << std::endl;
}


void
DeviceH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string ctorArgs = "";
//     std::string implPointers = "";
    int i = _serviceNames.size();
    while (i--) {
        ctorArgs += _serviceNames[i] + "* p" + _serviceNames[i] + "Impl" + (i ? ", " : "");
    }
    
    _out << std::endl
        << "class " << _deviceName << " : public DeviceRootImplAdapter" << std::endl
        << "{" << std::endl
        << "public:" << std::endl
        << indent(1) << _deviceName << "("
        << ctorArgs
        << ");" << std::endl
        << std::endl;
//         << "private:"
//         << std::endl;
    
    _out <<  std::endl
        << "private:" << std::endl
        << indent(1) << "virtual void actionHandler(Action* action);" << std::endl
        << indent(1) << "virtual void initStateVars(const std::string& serviceType, Service* pThis);" << std::endl
        << std::endl
        << indent(1) << "static std::string _deviceDescription;" << std::endl
        ;
    
    i = _serviceNames.size();
    while (i--) {
        _out << indent(1) << _serviceNames[i] << "* _p" << _serviceNames[i] << "Impl;" << std::endl;
    }
    
    _out
        << "};" << std::endl
        << std::endl
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceH::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    _serviceNames.push_back(serviceName);
    
    _out << std::endl
        << "class " << serviceName << std::endl
        << "{" << std::endl
        << indent(1) << "friend class " << _deviceName << ";" << std::endl
        << std::endl
        << "protected:"
        << std::endl;
}


void
DeviceH::serviceTypeEnd(const Service& service)
{
    _out << std::endl
        << "private:" << std::endl
        << indent(1) << "static std::string  _description;" << std::endl
        << indent(1) << "Service* _pService;" << std::endl
        << "};" << std::endl
        << std::endl;
}


void
DeviceH::action(const Action& action)
{
    _out
        << indent(1) << "virtual void " << action.getName() << "("
        ;
}


void
DeviceH::actionEnd(const Action& action)
{
    _out
        << ") = 0;"
        << std::endl;
}


void
DeviceH::actionBlockEnd()
{
    _out << std::endl
        << indent(1) << "virtual void initStateVars() = 0;" << std::endl
        << std::endl;
}


void
DeviceH::argument(const Argument& argument, bool lastArgument)
{
    _out
        << ((argument.getDirection() == "in") ? "const " : "")
        << _typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceH::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    _out
        << indent(1) << "void _set" << stateVar.getName() << "(const "
        << _typeMapper[stateVar.getType()] << "& val);"
        << std::endl
        << indent(1) << _typeMapper[stateVar.getType()]
        << " _get" << stateVar.getName() << "();"
        << std::endl;
}


DeviceCpp::DeviceCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + ".cpp").c_str())
// _out(&std::cout)
{
}


void
DeviceCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << preamble
//         << "#include <omm/upnp.h>" << std::endl
        << "#include \"" << _deviceName << ".h\"" << std::endl
        << "#include \"" << _deviceName << "Descriptions.h\"" << std::endl
        << std::endl
        << std::endl
        << "void" << std::endl
        << _deviceName << "::actionHandler(Action* pAction)" << std::endl
        << "{" << std::endl
        << indent(1) << "// the great action dispatcher" << std::endl;
    
    _stateVarInitializer
        << "void" << std::endl
        << _deviceName << "::initStateVars(const std::string& serviceType, Service* pThis)" << std::endl
        << "{"
        << std::endl;
    
    _firstService = true;
}


void
DeviceCpp::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string deviceDescriptionPath = deviceRoot.getDescriptionUri();
    std::string ctorArgs = "";
    int i = _serviceNames.size();
    while (i--) {
        ctorArgs += _serviceNames[i] + "* p" + _serviceNames[i] + "Impl" + (i ? ", " : "");
    }
    
    _out
        << "}" << std::endl
        << std::endl
        << std::endl
        << _stateVarInitializer.str()
        << "}" << std::endl
        << std::endl
        << std::endl
        << _deviceName << "::" << _deviceName << "("
        << ctorArgs
        << ") :" << std::endl
        << "DeviceRootImplAdapter()," << std::endl
        ;
    
    i = _serviceNames.size();
    while (i--) {
        _out 
            << "_p" << _serviceNames[i] << "Impl(p" << _serviceNames[i] << "Impl)"
            << (i ? ", " : "") << std::endl;
    }
    
    _out
        << "{" << std::endl
        << indent(1) << "_descriptions[\"" << deviceDescriptionPath << "\"]"
        << " = &" << _deviceName << "::_deviceDescription;" << std::endl;
    
    i = _serviceNames.size();
    while (i--) {
        _out
            << indent(1) << "_descriptions[\"" << _servicePaths[i] << "\"]"
            << " = &" << _serviceNames[i] << "::_description;" << std::endl;
    }
    
//     _out << std::endl;
//     
//     i = _serviceNames.size();
//     while (i--) {
//         _out
//             << indent(1) << "p" << _serviceNames[i] << "Impl->_pMediaRenderer = this;"
//             << std::endl;
//     }
    
    _out << std::endl
        << indent(1) << "Omm::StringDescriptionReader descriptionReader(_descriptions, \""
        << deviceDescriptionPath << "\");" << std::endl
        << indent(1) << "_pDeviceRoot = descriptionReader.deviceRoot();" << std::endl
        << indent(1) << "_pDeviceRoot->setImplAdapter(this);" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl
        << _getSet.str()
        << std::endl;
}


void
DeviceCpp::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    _serviceNames.push_back(serviceName);
    _currentService = serviceName;
    _servicePaths.push_back(service.getDescriptionPath());
    _firstAction = true;
    
    _out
        << indent(1) << (_firstService ? "" : "else ")
        << "if (pAction->getService()->getServiceType() == \""
        << service.getServiceType() << "\") {" << std::endl
        << indent(2) << "_p" << serviceName << "Impl->_pService = pAction->getService();" << std::endl
        << indent(2) << "std::string actionName = pAction->getName();" << std::endl
        << std::endl;
    
    _stateVarInitializer
        << indent(1) << (_firstService ? "" : "else ")
        << "if (serviceType == \"" << service.getServiceType() << "\") {" << std::endl
        << indent(2) << "_p" << serviceName << "Impl->_pService = pThis;" << std::endl
        << indent(2) << "_p" << serviceName << "Impl->initStateVars();" << std::endl
        << indent(1) << "}" << std::endl;
    
    _firstService = false;
}


void
DeviceCpp::serviceTypeEnd(const Service& service)
{
    _out
        << indent(1) << "}"
        << std::endl;
}


void
DeviceCpp::action(const Action& action)
{
    _out
        << indent(2) << (_firstAction ? "" : "else ")
        << "if (actionName == \"" << action.getName() << "\") {" << std::endl
        ;
    _currentOutArgs = "";
    _currentOutArgSetter.str("");
    _firstAction = false;
}


void
DeviceCpp::actionEnd(const Action& action)
{
    _out
        // do the implementation callback here
        << indent(3) << "_p" << _currentService << "Impl->" << action.getName()
        << "(" << _currentOutArgs << ");" << std::endl
        << _currentOutArgSetter.str()
        << indent(2) << "}"
        << std::endl;
}


void
DeviceCpp::argument(const Argument& argument, bool lastArgument)
{
    std::string argType = _typeMapper[argument.getRelatedStateVarReference()->getType()];
    _out
        << indent(3) << argType
        << " " /*<< argument.getDirection()*/ << argument.getName();
    if (argument.getDirection() == "in") {
        _out <<
            " = pAction->getArgument<" << argType << ">(\"" << argument.getName() << "\")";
    }
    _out
        << ";" << std::endl;
    _currentOutArgs += /*(argument.getDirection() == "in" ? "const " : "")*/
//         + argType + "& "
        /*+ */argument.getName()
        + (lastArgument ? "" : ", ");
    if (argument.getDirection() == "out") {
        _currentOutArgSetter
            << indent(3) << "pAction->setArgument<"
            << argType << ">(\"" << argument.getName()
            << "\", " << argument.getName() 
            << ");" << std::endl;
    }
}


void
DeviceCpp::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    std::string stateVarType = _typeMapper[stateVar.getType()];
    _getSet
        // StateVar setter method
        << "void" << std::endl
        << _currentService << "::_set" << stateVar.getName() 
        << "(const " << stateVarType << "& val)" << std::endl
        << "{" << std::endl
        << indent(1) << "_pService->setStateVar<" << stateVarType 
        << ">(\"" << stateVar.getName() << "\", val);" << std::endl
        << "}" << std::endl
        << std::endl
        << stateVarType << std::endl
        
        // StateVar getter method
        << _currentService << "::_get" << stateVar.getName() 
        << "()" << std::endl
        << "{" << std::endl
        << indent(1) << "return _pService->getStateVar<" << stateVarType 
        << ">(\"" << stateVar.getName() << "\");" << std::endl
        << "}" << std::endl
        << std::endl;
}


DeviceImplH::DeviceImplH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + "Impl.h.sample").c_str())
{
}


void
DeviceImplH::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << samplePreamble
        << "#ifndef " << Poco::toUpper(_deviceName) << "_IMPLEMENTATION_H" << std::endl
        << "#define " << Poco::toUpper(_deviceName) << "_IMPLEMENTATION_H" << std::endl
        << std::endl
        << "#include <omm/upnp.h>" << std::endl
        << "#include \"" << _deviceName << ".h\"" << std::endl
        << std::endl;
}


void
DeviceImplH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    _out
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceImplH::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();

    _out
        << "class " << serviceName << "Implementation : public " << serviceName << std::endl
        << "{" << std::endl
//         << "public:" << std::endl
//         << serviceName << "Implementation();" << std::endl
//         << std::endl
        << "private:"
        << std::endl;
}


void
DeviceImplH::serviceTypeEnd(const Service& service)
{
    _out
        << std::endl
        << indent(1) << "virtual void initStateVars();" << std::endl
//         << std::endl
//         << indent(1) << deviceName << "Implementation* _pDeviceImpl;" << std::endl
//         << std::endl
        << "};" << std::endl
        << std::endl;
}


void
DeviceImplH::action(const Action& action)
{
    _out
        << indent(1) << "virtual void " << action.getName() << "("
        ;
}


void
DeviceImplH::actionEnd(const Action& action)
{
    _out
        << ");"
        << std::endl;
}


void
DeviceImplH::argument(const Argument& argument, bool lastArgument)
{
    _out
        << ((argument.getDirection() == "in") ? "const " : "")
        << _typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


DeviceImplCpp::DeviceImplCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + "Impl.cpp.sample").c_str())
{
}


void
DeviceImplCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << samplePreamble
//         << "#include <omm/upnp.h>" << std::endl
        << "#include \"" << _deviceName << "Impl.h\"" << std::endl
        << std::endl;
}


void
DeviceImplCpp::serviceType(const Service& service)
{
    _serviceName = Omm::Urn(service.getServiceType()).getTypeName();
    _out
        << "void" << std::endl
        << _serviceName << "Implementation::initStateVars()" << std::endl
        << "{" << std::endl
        << "// you may set state variables here with the _set<state_variable_name>() methods" << std::endl
        << "// default values are already set, if defined by the service" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}


void
DeviceImplCpp::action(const Action& action)
{
    _out
        << "void" << std::endl << _serviceName << "Implementation::" << action.getName() 
        << "(";
}


void
DeviceImplCpp::actionEnd(const Action& action)
{
    _out
        << ")" << std::endl
        << "{" << std::endl
        << "// begin of your own code" << std::endl
        << std::endl
        << "// end of your own code" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}


void
DeviceImplCpp::argument(const Argument& argument, bool lastArgument)
{
    _out
        << ((argument.getDirection() == "in") ? "const " : "")
        << _typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


DeviceDescH::DeviceDescH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + "Descriptions.h").c_str())
{
}


void
DeviceDescH::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << preamble
        << "#ifndef " << Poco::toUpper(_deviceName) << "_DESCRIPTIONS_H" << std::endl
        << "#define " << Poco::toUpper(_deviceName) << "_DESCRIPTIONS_H" << std::endl
        << std::endl
        << "std::string " << _deviceName << "::_deviceDescription =" << std::endl
        << escapeDescription(*deviceRoot.getDeviceDescription())
        << ";" << std::endl
        << std::endl;
}


void
DeviceDescH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    _out
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceDescH::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    
    _out
        << "std::string " << serviceName << "::_description =" << std::endl
        << escapeDescription(*service.getDescription())
        << ";" << std::endl
        << std::endl;
}


std::string
DeviceDescH::escapeDescription(const std::string& description)
{
    std::string res = description;
    
    // escape all quotes
    std::string::size_type i = 0;
    while ((i = res.find("\"", i)) != std::string::npos) {
        res.insert(i, "\\");
        ++i; ++i;
    }
    
    // delete all carriage returns
    i = 0;
    while ((i = res.find("\r", i)) != std::string::npos) {
        res.erase(i, 1);
    }
    
    // escape all newlines
    i = 0;
    while ((i = res.find("\n", i)) != std::string::npos) {
        res.insert(i, "\\");
        ++i; ++i;
    }
    
    return "\"" + res + "\"";
}


DeviceCtrlImplH::DeviceCtrlImplH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + "CtrlImpl.h.sample").c_str())
{
}


void
DeviceCtrlImplH::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << samplePreamble
        << "#ifndef " << Poco::toUpper(_deviceName) << "_CTRL_IMPL_H" << std::endl
        << "#define " << Poco::toUpper(_deviceName) << "_CTRL_IMPL_H" << std::endl
        << std::endl
        << "#include <omm/upnp.h>" << std::endl
        << "#include \"" << _deviceName << "Ctrl.h\"" << std::endl
        << std::endl;
}


void
DeviceCtrlImplH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    _out
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceCtrlImplH::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    
    _out
        << "class " << serviceName << "ControllerImpl : public " << serviceName << "Controller" << std::endl
        << "{" << std::endl
        << "private:"
        << std::endl;
}


void
DeviceCtrlImplH::serviceTypeEnd(const Service& service)
{
    _out
        << std::endl
        << _eventedStateVars.str()
        << "};" << std::endl
        << std::endl;
    
    _eventedStateVars.str("");
}


void
DeviceCtrlImplH::action(const Action& action)
{
    _out
        << indent(1) << "virtual void _ans" << action.getName() << "("
        ;
}


void
DeviceCtrlImplH::actionEnd(const Action& action)
{
    _out
        << ");"
        << std::endl;
}


void
DeviceCtrlImplH::argument(const Argument& argument, bool lastArgument)
{
    _out
        << "const "
        << _typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceCtrlImplH::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
    _eventedStateVars
        << indent(1) << "virtual void _changed" << stateVar.getName() << "(const "
        << _typeMapper[stateVar.getType()] << "& val);"
        << std::endl;
}


DeviceCtrlImplCpp::DeviceCtrlImplCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + "CtrlImpl.cpp.sample").c_str())
{
}


void
DeviceCtrlImplCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << samplePreamble
        << "#include \"" << _deviceName << "CtrlImpl.h\"" << std::endl
        << std::endl;
}


void
DeviceCtrlImplCpp::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    _serviceName = serviceType.getTypeName();
}


void
DeviceCtrlImplCpp::argument(const Argument& argument, bool lastArgument)
{
    _out
        << "const "
        << _typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceCtrlImplCpp::action(const Action& action)
{
    _out
        << "void" << std::endl 
        << _serviceName << "ControllerImpl::_ans" << action.getName() 
        << "(";
}


void
DeviceCtrlImplCpp::actionEnd(const Action& action)
{
    _out
        << ")" << std::endl
        << "{" << std::endl
        << "// begin of your own code" << std::endl
        << std::endl
        << "// end of your own code" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}


void
DeviceCtrlImplCpp::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
    _out
        << "void" << std::endl 
        << _serviceName << "ControllerImpl::_changed" << stateVar.getName() << "(const "
        << _typeMapper[stateVar.getType()] << "& val)" << std::endl
        << "{" << std::endl
        << "// begin of your own code" << std::endl
        << std::endl
        << "// end of your own code" << std::endl
        << "}" << std::endl
        << std::endl
        << std::endl;
}



DeviceCtrlH::DeviceCtrlH(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + "Ctrl.h").c_str())
{
}


void
DeviceCtrlH::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << preamble
        << "#ifndef " << Poco::toUpper(_deviceName) << "_CTRL_H" << std::endl
        << "#define " << Poco::toUpper(_deviceName) << "_CTRL_H" << std::endl
        << std::endl
        << "#include <omm/upnp.h>" << std::endl
        << std::endl;
}


void
DeviceCtrlH::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string ctorArgs = "";
    int i = _serviceNames.size();
    while (i--) {
        ctorArgs += _serviceNames[i] + "Controller* p" + _serviceNames[i] + "Controller" + (i ? ", " : "");
    }
    
    _out << std::endl
        << "class " << _deviceName << "Controller : public Omm::ControllerImplAdapter" << std::endl
        << "{" << std::endl
        << "public:" << std::endl
        << indent(1) << _deviceName << "Controller("
        << "Omm::Device* pDevice, "
        << ctorArgs
        << ");" << std::endl
        << std::endl;
    
    i = _serviceNames.size();
    while (i--) {
        _out << indent(1)
            << _serviceNames[i] << "Controller* " << _serviceNames[i] 
            << "() { return _p" << _serviceNames[i] << "Controller; }"
            << std::endl;
    }
    
    _out <<  std::endl
        << "private:" << std::endl
        << indent(1) << "virtual void eventHandler(Omm::StateVar* pStateVar);" << std::endl
        << std::endl
        << indent(1) << "Omm::Device* _pDevice;" << std::endl
        ;
    
    i = _serviceNames.size();
    while (i--) {
        _out << indent(1) << _serviceNames[i] << "Controller* _p" << _serviceNames[i] << "Controller;" << std::endl;
    }
    
    _out
        << "};" << std::endl
        << std::endl
        << "#endif" << std::endl
        << std::endl;
}


void
DeviceCtrlH::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    _serviceNames.push_back(serviceName);
    
    _out
        << "class " << serviceName << "Controller" << std::endl
        << "{" << std::endl
        << indent(1) << "friend class " << _deviceName << "Controller;" << std::endl
        << std::endl
        << "public:"
        << std::endl;
}


void
DeviceCtrlH::serviceTypeEnd(const Service& service)
{
    _out
        << std::endl
        << _reqAction.str()
        << std::endl
        << _getEventedStateVars.str()
        << std::endl
        << "protected:" << std::endl
        << _ansAction.str()
        << std::endl
        << _changeEventedStateVars.str()
        << std::endl
        << "private:" << std::endl
        << _threadAction.str()
        << std::endl
        << indent(1) << "Omm::Service* _pService;" << std::endl
        << "};" << std::endl
        << std::endl;
    
    _reqAction.str("");
    _ansAction.str("");
    _threadAction.str("");
    _getEventedStateVars.str("");
    _changeEventedStateVars.str("");
}


void
DeviceCtrlH::action(const Action& action)
{
    _out
        << indent(1) << "void " << action.getName() << "("
        ;
    _reqAction
        << indent(1) << "void _req" << action.getName() << "("
        ;
    _ansAction
        << indent(1) << "virtual void _ans" << action.getName() << "("
        ;
    _threadAction
        << indent(1) << "void _thread" << action.getName() << "("
        ;
}


void
DeviceCtrlH::actionEnd(const Action& action)
{
    _out
        << ");"
        << std::endl;
    
    std::string reqActionArgs = _reqActionArgs.str();
    std::string::size_type l = reqActionArgs.length();
    if (l >= 2 && reqActionArgs.substr(l - 2) == ", ") {
        reqActionArgs = reqActionArgs.substr(0, l - 2);
    }
    _reqAction
        << reqActionArgs
        << ");"
        << std::endl;
    _ansAction
        << _ansActionArgs.str()
        << ") = 0;"
        << std::endl;
    _threadAction
        << "Omm::Action* pAction);"
        << std::endl;
    
    _reqActionArgs.str("");
    _ansActionArgs.str("");
}


void
DeviceCtrlH::argument(const Argument& argument, bool lastArgument)
{
    _out
        << ((argument.getDirection() == "in") ? "const " : "")
        << _typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
    
    if (argument.getDirection() == "in") {
        _reqActionArgs
            << "const "
            << _typeMapper[argument.getRelatedStateVarReference()->getType()]
            << "& " << argument.getName()
            << (lastArgument ? "" : ", ")
            ;
    }
    
    _ansActionArgs
        << "const "
        << _typeMapper[argument.getRelatedStateVarReference()->getType()]
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
}


void
DeviceCtrlH::stateVar(const StateVar& stateVar)
{
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
    _getEventedStateVars
        << indent(1)
        << _typeMapper[stateVar.getType()] << " "
        << "_get" << stateVar.getName() << "();"
        << std::endl;
    
    _changeEventedStateVars
        << indent(1) << "virtual void _changed" << stateVar.getName() << "(const "
        << _typeMapper[stateVar.getType()] << "& val) = 0;"
        << std::endl;
}


DeviceCtrlCpp::DeviceCtrlCpp(DeviceRoot* pDeviceRoot, const std::string& outputPath) :
StubWriter(pDeviceRoot, outputPath),
_out((_outputPath + _deviceName + "Ctrl.cpp").c_str())
{
}


void
DeviceCtrlCpp::deviceRoot(const DeviceRoot& deviceRoot)
{
    _out
        << preamble
        << "#include \"" << _deviceName << "Ctrl.h\"" << std::endl
        << std::endl;
    
    _firstStateVar = true;
}


void
DeviceCtrlCpp::deviceRootEnd(const DeviceRoot& deviceRoot)
{
    std::string ctorArgs = "";
//     std::string implPointers = "";
    int i = _serviceNames.size();
    while (i--) {
        ctorArgs += _serviceNames[i] + "Controller* p" + _serviceNames[i] + "Controller" + (i ? ", " : "");
    }
    
    // Event dispatcher
    
    _out
        << "void" << std::endl
        << _deviceName << "Controller::eventHandler(Omm::StateVar* pStateVar)" << std::endl
        << "{" << std::endl
        << _eventDispatcher.str()
        << "}" << std::endl
        << std::endl;
    
    // Device ctor ...
    _out << std::endl
//         << "class " << _deviceName << "Controller : public Omm::ControllerImplAdapter" << std::endl
//         << "{" << std::endl
//         << "public:" << std::endl
        << _deviceName << "Controller" << "::" << _deviceName << "Controller" << "("
        << "Omm::Device* pDevice, "
        << ctorArgs
        << ") :" << std::endl
        << "ControllerImplAdapter(pDevice)," << std::endl
        << "_pDevice(pDevice)," << std::endl;
    
    i = _serviceNames.size();
    while (i--) {
        _out
            << "_p" << _serviceNames[i] << "Controller(p" 
            << _serviceNames[i] << "Controller)" <<  (i ? ", " : "") << std::endl;
    }
    
    _out
        << "{" << std::endl;
    
    i = _serviceNames.size();
    while (i--) {
        _out
                    
            << indent(1) << "_p" << _serviceNames[i] << "Controller->_pService = "
            << "_pDevice->getService(\"" << _serviceTypes[i] << "\");"
            << std::endl;
    }
    
    _out
        << std::endl
        << indent(1) << "init();" << std::endl
        << "}" << std::endl
        << std::endl;
    
//     i = _serviceNames.size();
//     while (i--) {
//         _out << indent(1)
//             << _serviceNames[i] << "Controller* " << _serviceNames[i] 
//             << "() { return _p" << _serviceNames[i] << "Controller; }"
//             << std::endl;
//     }
//     
//     _out <<  std::endl
//         << "private:" << std::endl
//         << indent(1) << "virtual void eventHandler(Omm::StateVar* pStateVar);" << std::endl
//         << std::endl
//         << indent(1) << "Omm::Device* _pDevice;" << std::endl
//         ;
//     
//     i = _serviceNames.size();
//     while (i--) {
//         _out << indent(1) << _serviceNames[i] << "Controller* _p" << _serviceNames[i] << "Controller;" << std::endl;
//     }
//     
//     _out
//         << "};" << std::endl
//         << std::endl
//         << "#endif" << std::endl
//         << std::endl;
}


void
DeviceCtrlCpp::serviceType(const Service& service)
{
    Omm::Urn serviceType(service.getServiceType());
    _serviceTypes.push_back(service.getServiceType());
    std::string serviceName = serviceType.getTypeName();
    _serviceNames.push_back(serviceName);
    _currentService = serviceName;
}


void
DeviceCtrlCpp::serviceTypeEnd(const Service& service)
{
    _out
        << std::endl
        << _reqAction.str()
//         << std::endl
/*        << _getEventedStateVars.str()
        << std::endl
        << "protected:" << std::endl
        << _ansAction.str()
        << std::endl
        << _changeEventedStateVars.str()
        << std::endl
        << "private:" << std::endl*/
        << _threadAction.str()
        << std::endl
//         << indent(1) << "Service* _pService;" << std::endl
//         << "};" << std::endl
        << std::endl;
    
    _reqAction.str("");
//     _ansAction.str("");
    _threadAction.str("");
//     _getEventedStateVars.str("");
//     _changeEventedStateVars.str("");
}


void
DeviceCtrlCpp::action(const Action& action)
{
    _out
        << "void" << std::endl
        << _currentService << "Controller::" << action.getName() << "("
        ;
    _reqAction
        << "void " << std::endl
        << _currentService << "Controller::_req" << action.getName() << "("
        ;
    _threadAction
        << "void " << std::endl
        << _currentService << "Controller::_thread" << action.getName() << "("
        << "Omm::Action* pAction"
        ;
}


void
DeviceCtrlCpp::actionEnd(const Action& action)
{
    _out
        << ")" << std::endl
        << "{" << std::endl
        << indent(1) << "Omm::Action* pAction = _pService->getAction(\"" 
        << action.getName() << "\")->clone();" << std::endl
        << _inArgSetter.str()
        << indent(1) << "_pService->sendAction(pAction);" << std::endl
        << _outArgGetter.str()
        << "}" << std::endl
        << std::endl;
    
    std::string reqActionArgs = _reqActionArgs.str();
    std::string::size_type l = reqActionArgs.length();
    if (l >= 2 && reqActionArgs.substr(l - 2) == ", ") {
        reqActionArgs = reqActionArgs.substr(0, l - 2);
    }
    _reqAction
        << reqActionArgs
        << ")" << std::endl
        << "{" << std::endl
        << indent(1) << "Omm::Action* pAction = _pService->getAction(\"" 
        << action.getName() << "\")->clone();" << std::endl
        << _inArgSetter.str()
        << indent(1) << "Omm::ActionThread<"
        << _currentService << "Controller> thread(this, &"
        << _currentService << "Controller::_thread" << action.getName() << ", pAction);" << std::endl
        << indent(1) << "thread.start();" << std::endl
        << "}" << std::endl
        << std::endl;

    _threadAction
        << ")" << std::endl
        << "{" << std::endl
        << indent(1) << "_pService->sendAction(pAction);" << std::endl
        << _inArgGetter.str()
        << _outArgGetterLocal.str()
        << indent(1) << "_ans" << action.getName() << "(" << _allArgsCall.str() << ");" << std::endl
        << "}" << std::endl
        << std::endl;
    
    _inArgSetter.str("");
    _inArgGetter.str("");
    _outArgGetter.str("");
    _outArgGetterLocal.str("");
    _reqActionArgs.str("");
    _allArgsCall.str("");
}


void
DeviceCtrlCpp::argument(const Argument& argument, bool lastArgument)
{
    std::string argType = _typeMapper[argument.getRelatedStateVarReference()->getType()];
    
    _out
        << ((argument.getDirection() == "in") ? "const " : "")
        << argType
        << "& " << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
    
    _allArgsCall
        << argument.getName()
        << (lastArgument ? "" : ", ")
        ;
    
    if (argument.getDirection() == "in") {
        _inArgSetter
            << indent(1) << "pAction->setArgument<" << argType << ">(\""
            << argument.getName() << "\", "
            << argument.getName() << ");"
            << std::endl;
        
        _inArgGetter
            << indent(1) << argType << " " << argument.getName()
            << " = pAction->getArgument<" << argType << ">(\""
            << argument.getName() << "\");"
            << std::endl;
        
        _reqActionArgs
            << "const "
            << argType
            << "& " << argument.getName()
            << (lastArgument ? "" : ", ")
            ;
    }
    else if (argument.getDirection() == "out") {
        _outArgGetter
            << indent(1) << argument.getName()
            << " = pAction->getArgument<" << argType << ">(\""
            << argument.getName() << "\");"
            << std::endl;
        
        _outArgGetterLocal
            << indent(1) << argType << " " << argument.getName()
            << " = pAction->getArgument<" << argType << ">(\""
            << argument.getName() << "\");"
            << std::endl;
    }
    
//     if (argument.getDirection() == "in") {
//     }
    
//     _ansActionArgs
//         << "const "
//         << argType
//         << "& " << argument.getName()
//         << (lastArgument ? "" : ", ")
//         ;
}


void
DeviceCtrlCpp::stateVar(const StateVar& stateVar)
{
    std::string varType = _typeMapper[stateVar.getType()];
    
    if (stateVar.getName().substr(0, std::string("A_ARG_TYPE_").size()) == "A_ARG_TYPE_") {
        return;
    }
    
    if (!stateVar.getSendEvents()) {
        return;
    }
    
//     _getEventedStateVars
//         << indent(1)
//         << varType << " "
//         << "_get" << stateVar.getName() << "();"
//         << std::endl;
//     
//     _changeEventedStateVars
//         << indent(1) << "virtual void _changed" << stateVar.getName() << "(const "
//         << varType << "& val) = 0;"
//         << std::endl;
    
    _eventDispatcher
        << indent(1) << (_firstStateVar ? "" : "else ")
        << "if (pStateVar->getName() == \"" << stateVar.getName() << "\") {" << std::endl
        << indent(2) << varType << " val;" << std::endl
        << indent(2) << "pStateVar->getValue(val);" << std::endl
        << indent(2) << "_p" << _currentService << "Controller->_changed" << stateVar.getName() << "(val);" << std::endl
        << indent(1) << "}" << std::endl;
    
    _out
        << varType << std::endl
        << _currentService << "Controller::_get" << stateVar.getName() << "()" << std::endl
        << "{" << std::endl
        << indent(1) << "return _pService->getStateVar<" << varType << ">(\"" << stateVar.getName() << "\");" << std::endl
        << "}" << std::endl
        << std::endl;
    
    _firstStateVar = false;
}